# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <codecell>

#
# Matlab Coder Generated C Code uses a data structure to represent variable sized matlab arrays
#  it's called emx_array
# This code tries to interface with a very simple matlab script that takes an array and multiplies each element by itself
#

import ctypes
import numpy

LIBTEST = '/home/trevorsweetnam/Dropbox/notebooks/eef/emxarr/codegen/dll/emx_test/'
EMX = ctypes.cdll.LoadLibrary(LIBTEST + 'emx_test.so')
init = EMX.emx_test_initialize()
print '\nInitialize...\n'

# <codecell>

def TestEmxNumpy():
    """ Test the EMX Api provided by the matlab coder 
        TestEmxAPI below works...this is trying to get a 
        numpy version to work
    """

    # Create a data structure to hold the pointer generated by 
    #  emxCreateWrapper...
    class Opaque(ctypes.Structure):
        pass
    
    # make some random data to pass in
    data_in = numpy.array([1., 2., 4., 8., 16.])
    # create an empty array of the same size for the output
    data_ou = numpy.zeros(len(data_in))
    
    # put this in a ctypes array
    ina = (ctypes.c_double * data_in.shape[0])(*data_in)
    oua = (ctypes.c_double * data_ou.shape[0])(*data_ou)
    # create a pointer for these arrays & set the rows and columns of the matrix
    inp = ctypes.pointer(ina)
    oup = ctypes.pointer(oua)
    
    nrows = ctypes.c_int(data_in.shape[0])
    ncols = ctypes.c_int(1)

    # use EMX.emxCreateWrapper_real_T(double *data, int rows, int cols) to generate an emx wrapping the data 
    # input arg types are a pointer to the data NOTE it's not great to have to resize the ctypes.c_double
    EMX.emxCreateWrapper_real_T.argtypes = [ctypes.POINTER(ctypes.c_double * data_in.shape[0]), ctypes.c_int, ctypes.c_int]
    # a pointer to the emxArray is returned and stored in Opaque
    EMX.emxCreateWrapper_real_T.restype = ctypes.POINTER(Opaque)
    # use emxCreateWrapper
    in_emx = EMX.emxCreateWrapper_real_T(inp, nrows, ncols)
    ou_emx = EMX.emxCreateWrapper_real_T(oup, nrows, ncols)
    
    # so now we have to emx's created and have pointers to them we can run the emx_test
    # emx test looks like this in matlab
    #
    # function res = emx_test ( in )
    #     res = in .* in;
    # end
    #
    # so basically it multiplies each element of the matrix by itself
    # 
    # therefore [1., 2., 4., 8., 16.] should become [1., 4., 8., 64., 256.]

    EMX.emx_test(in_emx, ou_emx)
    
    # and voila...that's what we get
    print ina[:data_in.shape[0]]
    print oua[:data_in.shape[0]]
        
%timeit TestEmxNumpy()   

# <codecell>

class EmxArray(ctypes.Structure):

    boolean_T = ctypes.c_ubyte
    _fields_ = [
        ('data', ctypes.POINTER(ctypes.c_double)),
        ('size', ctypes.POINTER(ctypes.c_int)),
        ('allocatedSize', ctypes.c_int),
        ('numDimensions', ctypes.c_int),
        ('canFreeData', boolean_T)]

    __all__ = ['boolean_T', 'emxArray_real_T']

    
    # would be nice to have a way of printing the contents etc
    #def __str__(self):
    #    return str(self.data)

def TestEMX():
    """ Test the EMX """
    # define some data

    data_in = [1., 2., 4., 8., 16.]
    L = len(data_in)

    ina = EmxArray()
    ina.data = (ctypes.c_double * L)(*data_in)
    ina.size = (ctypes.c_int * 1)(L)
    ina.allocatedSize = 5
    ina.numDimensions = 2
    ina.canFreeData = False

    # set up an array where the output can be stored
    out = EmxArray()
    out.data = (ctypes.c_double * L)(*[0] * L)
    out.size = (ctypes.c_int * 1)(L)
    out.allocatedSize = 5
    out.numDimensions = 2
    out.canFreeData = False

    # create pointers to the two arrays
    #ina_p = ctypes.pointer(ina)
    #out_p = ctypes.pointer(out)

    print 'Before: '
    print 'In: ', ina.data[:L]
    print ina
    #print ina_p
    print 'Out:', out.data[:L]
    print out
    #print out_p

    # --- now emx_test takes a double and returns a double and an EmxArray
    # emx_test takes a pointer to an array and a pointer to an array out
    print '\nRunning emx_test.....\n'
    EMX.emx_test.argtypes = [ctypes.POINTER(EmxArray), ctypes.POINTER(EmxArray)]
    EMX.emx_test.restype = None
    #EMX.emx_test(ina_p, out_p)

    EMX.emx_test(ctypes.byref(ina), ctypes.byref(out))
    
    print 'After: '
    print 'In: ', ina.data[:L]
    print ina
    #print ina_p
    print 'Out:', out.data[:L]
    print out
    #print out_p

#TestEMX()

# <codecell>

#print '\nTerminate......\n'
#term = EMX.emx_test_initialize()

# <codecell>

def TestDouble():
    """
        Test passing a double to emx_test - this works ok...
    """
    #
    # Proof that this works for a single double
    #

    ina = ctypes.c_double(2)

    print 'Before: '
    print 'In: ', ina.value

    # --- now emx_test takes a double and returns a double and an EmxArray
    # emx_test takes a pointer to an array and a pointer to an array out
    print '\nRunning emx_test\n'
    EMX.emx_test.argtypes = [ctypes.c_double]
    EMX.emx_test.restype = ctypes.c_double
    out = EMX.emx_test(ina)

    print 'After: '
    print 'Out: ', out
    
#TestDouble()

# <codecell>

# 
# emcARRAY API
# the API provides a number of functions for working with EMX objects
#

#EMX.emxFree_real_T
#EMX.emxInit_real_T

#EMX.emxInit_real_T
#EMX.emxCreate_real_T

#EMX.emxCreateWrapperND_real_T 
# this one creates an array and creates space for the data

#EMX.emxCreateWrapper_real_T(*data, num_rows, num_columns)
# this one creates an array and points at data on the heap

#EMX.emxDestroyArray_real_T

#EMX.emxCreate_real_T(ctypes.c_int(1), ctypes.c_int(1))

# <codecell>

def TestEmxAPI():
    """ Test the EMX Api provided by the matlab coder """

    # Create a data structure to hold the pointer generated by 
    #  emxCreateWrapper...
    class Opaque(ctypes.Structure):
        pass
    
    # make some random data to pass in
    data_in = [1., 2., 4., 8., 16.]
    L = len(data_in)
    # create an empty array of the same size for the output
    data_ou = [0] * L
    
    # put this in a ctypes array
    ina = (ctypes.c_double * L)(*data_in)
    oua = (ctypes.c_double * L)(*data_ou)
    # create a pointer for these arrays & set the rows and columns of the matrix
    inp = ctypes.pointer(ina)
    oup = ctypes.pointer(oua)
    
    nrows = ctypes.c_int(1)
    ncols = ctypes.c_int(L)

    # use EMX.emxCreateWrapper_real_T(double *data, int rows, int cols) to generate an emx wrapping the data 
    # input arg types are a pointer to the data NOTE it's not great to have to resize the ctypes.c_double
    EMX.emxCreateWrapper_real_T.argtypes = [ctypes.POINTER(ctypes.c_double * L), ctypes.c_int, ctypes.c_int]
    # a pointer to the emxArray is returned and stored in Opaque
    EMX.emxCreateWrapper_real_T.restype = ctypes.POINTER(Opaque)
    # use emxCreateWrapper
    in_emx = EMX.emxCreateWrapper_real_T(inp, nrows, ncols)
    ou_emx = EMX.emxCreateWrapper_real_T(oup, nrows, ncols)
    
    # so now we have to emx's created and have pointers to them we can run the emx_test
    # emx test looks like this in matlab
    #
    # function res = emx_test ( in )
    #     res = in .* in;
    # end
    #
    # so basically it multiplies each element of the matrix by itself
    # 
    # therefore [1., 2., 4., 8., 16.] should become [1., 4., 8., 64., 256.]

    EMX.emx_test(in_emx, ou_emx)
    
    # and voila...that's what we get
    print ina[:L]
    print oua[:L]
     
#TestEmxAPI()   

# <codecell>


# <codecell>


# <codecell>


# <codecell>


# <codecell>


